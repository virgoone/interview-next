---
title: React 18 新特性
---

# React 18 有什么新特性？

## 核心回答

React 18 的核心升级是 **"并发渲染"**（底层重构，让渲染可中断、可恢复，优先处理高优先级任务），在此基础上衍生出以下关键新特性：

1. **新渲染 API**：`ReactDOM.createRoot` 替代 `ReactDOM.render`，自动启用并发渲染，支持 `root.unmount()` 卸载应用，移除老版本回调参数。

2. **自动批处理（Automatic Batching）**：所有场景（包括 `setTimeout`、`Promise` 等异步场景）都能合并多个 `setState` 更新为一次渲染，大幅减少渲染次数。

3. **Transitions API**：`useTransition`/`startTransition` 标记非紧急更新（如搜索结果渲染），优先处理紧急更新（如输入、点击），避免 UI 卡顿。

4. **Suspense 增强**：从仅支持代码分割，扩展到支持数据获取和流式 SSR，等待异步操作时显示 `fallback` 占位（如 loading）。

5. **服务器组件（RSC）**：服务器端渲染组件，不包含客户端代码（如 `useState`、事件处理），仅传输渲染结果，减少客户端 JS 包体积。

6. **实用新 Hook**：`useId`（生成跨端唯一 ID）、`useSyncExternalStore`（订阅外部数据源）、`useInsertionEffect`（CSS-in-JS 样式注入）。

## 延伸问题-回答

1. **延伸问题**：React 18 的并发渲染是如何实现的？

回答：核心依赖"调度器（Scheduler）"和"并发更新机制"——①调度器：为任务分配优先级（如 Immediate > UserBlocking > Normal > Low），高优先级任务可中断低优先级任务；②并发更新：React 18 引入"更新队列优先级"，低优先级更新标记为"可中断"，高优先级任务到来时放弃当前渲染，完成后重新计算低优先级更新，避免阻塞主线程。

2. **延伸问题**：`useTransition` 和 `useDeferredValue` 的区别？

回答：核心是"作用对象不同"，互补使用——①`useTransition`：作用于"更新函数"，标记某段更新逻辑为非紧急（如 `startTransition(() => setSearchResult(...))`）；②`useDeferredValue`：作用于"状态值"，生成状态的延迟版本（如 `const deferredFilter = useDeferredValue(filter)`），适合直接基于状态渲染的场景；③相同点：均基于并发渲染，可被高优先级任务中断，避免 UI 卡顿。

3. **延伸问题**：自动批处理有哪些例外情况？

回答：以下场景不触发自动批处理，状态更新立即渲染——①`flushSync` 包裹的更新（手动取消批处理）；②错误边界捕获错误时的更新；③服务器组件中的更新；④浏览器原生事件中同步执行的更新（异步嵌套仍会批处理）。

4. **延伸问题**：服务器组件（RSC）和客户端组件如何通信？

回答：通过"Props 单向传递"通信——①服务器组件可向客户端组件传递数据、回调函数；②客户端组件不能向服务器组件传递 Props（服务器组件已在服务端渲染完成）；③共享数据：服务器组件获取数据后传递给客户端组件，或通过全局状态库（如 Redux）共享（客户端组件订阅即可）。

> （注：文档部分内容可能由 AI 生成）

